# 第一部分 进入内核前的苦力活

## 1 Linux开机初始化

- 开机后初始化指向BIOS：开机后，CPU初始化PC寄存器为`0xFFFF0`，然后按照PC寄存器的值到内存中对应的地址寻找这条指令执行。
- 读取硬盘启动区（第一扇区）：硬盘第一扇区的512字节的最后两个字节分别是`0x55`和`0xaa`，将512字节的二进制数据从硬盘搬运到内存。该数据是`boot/bootsect.s`的二进制文件，存放在启动区的第一个扇区。
- 加载到内存`0x7c00`位置，并跳转到这里：如下代码表示把`0x07c0`复制到ax寄存器，再复制到ds寄存器。为了CPU在16位实模式下能访问20位地址线，左移4位得到`0x7c00`。

```asm
BOOTSEG = 0x07c0
start: 
  mov ax,#BOOTSEG
  mov ds,ax
```

## 2 从0x7c00到0x90000

### 2.1 寄存器初始化

代码路径：`boot/bootsect.s`
```asm
BOOTSEG = 0x07c0			! original address of boot-sector
INITSEG = 0x9000			! we move boot here - out of the way

start:
    mov	ax,#BOOTSEG
    mov	ds,ax         ! ds=0x07c0
    mov	ax,#INITSEG   ! ax=0x9000
    mov	es,ax         ! es=0x9000
    mov	cx,#256       ! cx=256
    sub	si,si         ! si=0
    sub	di,di         ! di=0
```

执行上述代码后，各寄存器的值为：
- ds数据段：0x07c0
- es附加段：0x9000
- cx寄存器：256
- si原变址：0
- di目的变址：0

### 2.2 从0x7c00到0x90000：

```asm
start:
  rep movw 
```

rep表示重复执行后面的指令，movw表示复制一个字（2个字节），重复执行的次数为256次（cx寄存器的值），从`ds:si`处复制到`es:di`处（即从0x7c00到0x90000），一共复制2*256=512个字节。

该操作表示将内存地址`0x7c00`处开始往后的512个字节的数据，复制到`0x90000`处开始的后面512字节的地方。

### 2.3 跳转到0x9000:go处执行

```asm
start:
	jmpi go,INITSEG  ! cs=0x9000
```

## 3 做好访问内存的基础准备工作

### 3.1 寄存器的作用

- cs寄存器：表示代码段寄存器，CPU即将要执行的代码在内存中的位置，就是由`cs:ip`配合指向的。
- ds寄存器：表示数据段寄存器，作为访问内存数据时的基地址。
- es寄存器：表示扩展段寄存器。
- ss寄存器：表示栈段寄存器，配合栈指针寄存器sp表示此时的栈顶地址，由`ss:sp`配合指向的。

### 3.2 CPU访问内存的三种途径

- `cs:ip`访问代码
- `ds:xxx`访问数据
- `ss:sp`访问栈

### 3.3 寄存器初始化

```asm
go:	mov	ax,cs           ! ax=0x9000
	mov	ds,ax           ! ds=0x9000
	mov	es,ax           ! es=0x9000
! put stack at 0x9ff00.
	mov	ss,ax           ! ss=0x9000
	mov	sp,#0xFF00		! arbitrary value >>512
```

### 3.4 内容总结

1. 代码从硬盘移动到内存，在内存中从`0x7c00`复制到`0x90000`处。
2. 数据段寄存器ds和代码段寄存器es设置为`0x9000`。
3. 栈顶地址设置为`0x9FF00`，其中栈段寄存器ss为`0x9000`，栈基址寄存器sp为`0xFF00`。

## 4 把全部的操作系统代码从硬盘搬到内存

### 4.1 把剩下的操作系统代码从硬盘搬到内存

```asm
SETUPLEN = 4			! nr of setup-sectors

load_setup:
    mov	dx,#0x0000		! drive 0, head 0
    mov	cx,#0x0002		! sector 2, track 0
    mov	bx,#0x0200		! address = 512, in INITSEG
    mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors
    int	0x13			! read it
```

上述代码主要作用：从硬盘的第2个扇区开始，把数据加载到内存的`0x90200`处，共加载4个扇区。

```asm
load_setup:
    jnc	ok_load_setup		! ok - continue
    mov	dx,#0x0000
    mov	ax,#0x0000		! reset the diskette
    int	0x13
    j	load_setup
```

上述代码主要作用：如果成功，就跳转到`ok_load_setup`标签的代码，如果失败，就重复执行本段代码。

```asm
SYSSEG   = 0x1000		! system loaded at 0x10000 (65536).
SETUPSEG = 0x9020			! setup starts here

ok_load_setup:
    ...
	mov	ax,#SYSSEG
	mov	es,ax		! segment of 0x010000
	call	read_it
    ...
	jmpi	0,SETUPSEG
```

上述代码主要作用：把从硬盘第6个扇区开始往后的240个扇区，加载到内存`0x10000`处，再跳转到`0x90200`处（硬盘第2个扇区开始的位置）。

### 4.2 操作系统的编译过程

操作系统的编译过程是通过Makefile和build.c完成，过程如下：
1. 把bootsect.s编译成bootsect放在硬盘的第1扇区。
2. 把setup.s编译成setup放在硬盘的第2\~5扇区。
3. 把剩下的全部代码（head.s作为开头，与各种.c和其他.s等文件一起）编译并链接成system放在硬盘随后的240个扇区中。