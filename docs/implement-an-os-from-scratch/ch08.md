# 第8章 内存管理

## 1 获取内存信息

BIOS的启动与执行流程：
1. 计算机启动后，将主板BIOS映射到处理器的地址空间`0x000F0000`\~`0x000FFFFF`，并将处理器的CS寄存器和指令指针IP分别设置为`0xF000`和`0xFFF0`。
2. BIOS中的程序负责开机后自检以及各种设备的初始化。
3. 最后BIOS加载操作系统加载器，将控制权交给操作系统加载器BootLoader。

读取内存信息流程：
- BIOS使用一个称为E820的数据结构表示内存地址的每一个段，每条记录使用20个字节，其中8个字节表示内存段的起始地址，8个字节表示段的尺寸，4个字节表示段的类型。

```c
// 使用packed告知GCC编译器，分配结构体变量时不要进行对齐
struct e820entry {
    uint64_t addr; // 内存段的起始地址
    uint64_t size; // 内存段的尺寸
    uint32_t type; // 内存段的类型
} __attribute__((packed));
```

- 每执行一次指令`int`，BIOS会返回一条E820记录。
- BIOS数据区的索引使用寄存器EBX存储，使用寄存器ECX表示每次读取的E820记录的大小。
- BIOS会从寄存器DI读出指定的存储E820记录的内存地址，将该记录复制到`ES:DI`指向的内存处。

计算物理内存大小（代码见`codes/implement-an-os-from-scratch/c8/mm/memory.c`）：
- 存储E820记录的区域在内存`0x13000`处。
- 当类型为RAM时（表示可用物理内存区域），计算物理内存大小。
- 最大值就是可用物理内存的大小，并使用`print`打印物理内存大小。

## 2 页面管理

- 划分页面：定义一个1M的数组记录页面状态，可以表示4GB物理内存。
- 为内核映像保留页面：为内核预留64MB内存（即16K个页面），用1表示页面已占用。
- 分配页面：按照顺序遍历页面的`pages`数组，申请最近的空闲页面。
- 归还页面：根据页面地址计算得到数组pages中的索引，将其对应的数据元素恢复为0，标识此页面空闲。

## 3 映射物理内存

- 原因：在分页模式下，处理器访问物理内存时，必须通过虚拟地址访问，需要为每个物理内存分配一个对应的虚拟地址，并在页表中建立起映射关系。
- 解决方案：在开启分页前，建立映射光景只要覆盖用于映射的页面，在开启分页后，从第1个阶段映射覆盖的内存中申请页面作为页表，使用C程序完成后续的全部物理内存的映射。
- 原理：使用线性映射方式。
- 公式：`VA（虚拟地址）= PA（物理地址）+ 0xffff888000000000`
- 具体实现：
    - 第1阶段映射：在地址`0x55000`、`0x56000`和`0x57000`处分配3个页面，分别作为线性映射的三级页表、二级页表和第33张一级页表。
    - 第2阶段映射：进入64位模式之后，使用C代码建立全部物理内存与虚拟地址的映射关系，代码见`codes/implement-an-os-from-scratch/c8/mm/memory.c`的`map_range`函数。实现以页面为单位的虚拟地址到物理地址的映射。

## 4 内存块管理

- 块管理思想：采用池化的思想，预先从内存中申请空闲页面，然后将页面划分为若干小内存块缓存在资源池中，使用时从资源池中获取。
- 空闲内存块链表：将空闲内存块组织为一个链表，档页面中的内存块全部空闲时，将页面释放，使用`refcnt`记录块数。

```c
// 记录页面中内存块的使用情况，即桶链表
struct bucket_desc {
    void* freeptr; // 空闲块链表第一个节点的地址
    struct bucket_desc* next; // 指向下一个页面
    short refcnt; // 记录页面中使用的块数
};

// 用于存储不同块大小的内存块链表
struct bucket_dir {
    uint16_t size; // 块大小
    struct bucket_desc* bdesc; // 对应的桶链表
};
```

- 主要功能：
    - 分配内存块：遍历数组`bucket_dir`，找到满足可用内存大小条件的链表，然后找到可用空闲内存块，最后分配内存，如果链表为空或者链表中没有可用内存块，就通过页面管理申请一个空闲页面作为新链表，将其分块后插入链表的表头。
    - 释放内存块：根据内存块的地址，确定其所在页面的地址，将释放的内存块插到空闲链表的表头。如果计数器为0，则标识页内所有的块全部空闲，将这个物理页从链表中删除，并调用`free_page`函数释放页面。