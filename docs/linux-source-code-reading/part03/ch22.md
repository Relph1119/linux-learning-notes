# 第22回 从内核态切换到用户态

## 22.1 内核态和用户态的本质——特权级

CPU的保护机制：
- 将CR0寄存器的PE位（最低位）开启，表示开启了分段保护机制。
- 将CR0寄存器的PG位（最高位）开启，表示开启了分页保护机制。

CPU的特权级：
- `jmp xxx`：不涉及段的变换，不检查特权级。
- `jmp yyy:xxx`：段选择子的低2位表示RPL（请求特权级），CPU把段选择子到全局描述符表中寻找段描述符，从中找到段基址。
- `yyy`对应的段描述符：称为目标段描述符，最低2位表示DPL（目标代码段特权级）。

总之，代码跳转只能在同特权级之间跳转，数据访问只能高特权级访问低特权级。

## 22.2 特权级转换的方式

规则：处于用户态的程序，通过触发中断，可以进入内核态，之后再通过中断返回，恢复为用户态。

```c
// include/asm/system.h
#define move_to_user_mode() \
__asm__ ("movl %%esp,%%eax\n\t" \
	"pushl $0x17\n\t" \
	"pushl %%eax\n\t" \
	"pushfl\n\t" \
	"pushl $0x0f\n\t" \
	"pushl $1f\n\t" \
	"iret\n" \
	"1:\tmovl $0x17,%%eax\n\t" \
	"movw %%ax,%%ds\n\t" \
	"movw %%ax,%%es\n\t" \
	"movw %%ax,%%fs\n\t" \
	"movw %%ax,%%gs" \
	:::"ax")
```

基本思路：
- 模拟中断过程，进行5次压栈操作，其中SS为`0x17`，CS为`0x0f`。
- CS寄存器最后2位是11，表示用户态，特权级表示CPL，即当前处理器特权级。
- CS寄存器倒数第3位TI为1，表示描述符索引从局部描述符表（LDT）中获取。
- 经过`iretd`返回之后，当前处理器特权级变成了用户态特权级。
- 中断返回后，跳转到标签`1`处继续执行。

本质上，`iretd`指令做了特权级转换和描述符表切换的操作。