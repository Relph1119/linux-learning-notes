.text
.code32
    # 将0x10（段索引对应的是内核数据段，位于全局段描述符表的第3项，故为10，TI为0，特权级为0，因此是0000000000001000）存入AX寄存器中
    mov $0x10, %ax
    # 从DS寄存器中获取段的信息
    mov %ax, %ds
    # 由于使用了stosl指令，其目的地址是ES:EDI，需要初始化段寄存器ES
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    mov %ax, %ss

    lgdt gdtr

# 填充二级页表项
    mov $0x32000, %edi
    # 从第一个页表项开始
    mov $0x33000 + 3, %eax
1:
    # 将寄存器EAX中的值存储到寄存器EDI记录的内存地址处，完成页表项的填充，同时该指令会将EDI中记录的地址自动增加4个字节
    stosl
    # 更新EAX为下一个一级页表的地址
    add $0x1000, %eax
    # 指向下一个页表项
    add $4, %edi

    # 是否完成所有页表项的填充
    cmp $(0x32000 + 32 * 8 - 8), %edi
    jle 1b

# 填充一级页表项
    mov $0x33000, %edi
    mov $0x0 + 3, %eax
2:
    stosl
    add $0x1000, %eax
    add $4, %edi

    cmp $(0x33000 + 512 * 8 * 32 - 8), %edi
    jle 2b

# 映射物理内存
    # 填充的二级表起始地址为0x56000之后的32个页表项
  mov $0x56000, %edi
  mov $0x33000 + 3, %eax
3:
    stosl
    add $0x1000, %eax
    add $4, %edi

    cmp $(0x56000 + 32 * 8 - 8), %edi
    jle 3b

    # 使能PAE，开启处理器的物理地址扩展特性，可以寻址超过32位
    mov %cr4, %eax
    btsl $5, %eax
    movl %eax, %cr4

    # 设置CR3寄存器指向根页表的物理地址，即指向四级页表地址
    movl $0x30000, %eax
    movl %eax, %cr3

    # 使能64位模式，使能syscall指令
    mov $0xc0000080, %ecx
    # 从寄存器ECX中读出MSR寄存器的地址，然后读取MSR低32位到寄存器EAX中，读取高32位到EDX寄存器中
    rdmsr
    bts $8, %eax
    bts $0, %eax
    wrmsr

    # 设置CR0的PG位，开启分页
    mov %cr0, %eax
    bts $31, %eax
    mov %eax, %cr0

    # 段选择子是0x8（段索引是1，使用全局段描述符表TI是0，特权级是00，即0000000000001000）
    # 64位部分的起始物理地址是0x100000，段基址为0，所以段内偏移地址为0xffffffff80100000，由于会被截断，使用0x100000
    # 经过恒等映射后，虚拟地址0x100000被翻译为物理地址0x100000
    # 长跳转指令ljmpl [段选择子] [段内偏移地址]
    ljmp $0x8, $0x100000

gdt:
  # 段描述符表的第0项保留不用
  .quad 0x0000000000000000
  # 第1项定义内核代码段
  .quad 0x00209a0000000000
  # 第2项定义内核数据段
  .quad 0x0000920000000000
gdt_end:

gdtr:
  .word gdt_end - gdt
  .long gdt

# 建立内核映像的虚拟地址到物理地址的映射，从0xffffffff80000000映射到物理地址0，映射64MB大小的物理内存区域
# 需要32个一级页表，以及四级、三级、二级页表各1个，其低48位0xfff80000000用于寻址
# 其中前9位作为四级页表的索引，第2个9位作为三级页表的索引，第3个9位作为二级页表的索引，第4个9位作为一级页表的索引
# 四级页表的基址是64K，即0x10000
.org 0x10000
pml4:
    # 将四级页表的第0项指向三级页表0x53000
    .quad 0x0000000000053003
    .fill 272, 8, 0
    # 线性映射的三级页表
    .quad 0x0000000000055003
    .fill 237, 8, 0
    # 三级页表地址是0x31000
    .quad 0x0000000000031003

.org 0x11000
pml3:
  .fill 510, 8, 0
   # 二级页表地址是0x32000，当前内核使用4K页面，页面尺寸位为0
  .quad 0x0000000000032003
  .fill 1, 8, 0

# 先将二级页表项全部清零，再使用代码自动完成二级页表项的填充
.org 0x12000
  .fill 512, 8, 0

.org 0x13000
  .fill 512 * 32, 8, 0

# 将三级页表的第0项指向二级页表0x54000
.org 0x33000
  .quad 0x0000000000054003
  .fill 511, 8, 0

# 将二级页表的第0项指向映射内核映像的第1个一级页表0x33000
.org 0x34000
  .quad 0x0000000000033003
  .fill 511, 8, 0

.org 0x35000
  # 线性映射的二级页表
  .quad 0x0000000000056003
  .fill 511, 8, 0

.org 0x36000
  .fill 32, 8, 0
  # 线性映射的第33张的一级页表
  .quad 0x0000000000057003
  .fill 479, 8, 0

.org 0x37000
  .fill 512, 8, 0